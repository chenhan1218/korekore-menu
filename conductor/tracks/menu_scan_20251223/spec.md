# 菜單掃描功能 - 規格說明

## 功能概述 (Overview)

菜單掃描功能是 KoreKore 的核心入口，允許用戶上傳菜單圖片，系統解析並提供結構化的菜單數據。此階段（MVP）暫時使用 Mock 數據回傳，不進行 Gemini API 實際對接。

---

## 功能需求 (Functional Requirements)

### FR-1: 圖片上傳
- 支援 JPG、PNG 格式的圖片上傳
- **檔案上傳限制**：15MB（支援現代手機高清照片）
- **前端自動壓縮**：若圖片超過 5MB，前端自動壓縮至 5MB 以下
  - 使用 JPEG 品質 85-90% 以保持菜單清晰度
  - 用戶無感，自動處理
- 上傳成功後顯示進度反饋
- 上傳失敗時顯示友善的錯誤提示

### FR-2: Mock 數據解析
- 接收上傳圖片後，系統立即返回 Mock 菜單數據
- Mock 數據包含 20 個菜項
- 每個菜項包含：
  - `id`: 唯一字串 ID
  - `name_jp`: 日文菜名
  - `name_zh`: 繁體中文翻譯（使用台灣人習慣用語，如「唐揚雞」、「生啤酒」）
  - `variants`: 規格陣列（大盛/並盛/小盛等），即使只有單一價格也必須包在陣列中
    - `spec`: 規格名稱（如「單點」、「定食」、「大盛」等）
    - `price`: 價格數字
    - `tax_type`: 「稅込」或「稅拔」（不能省略）

### FR-3: 菜單展示
- 以卡片式清單展示解析結果，清楚顯示規格和價格
- 價格旁必須標註「稅込」或「稅拔」
- 支援用戶勾選想要的品項

---

## 受理條件 (Acceptance Criteria)

- ✅ 用戶可成功上傳菜單圖片（JPG/PNG，≤15MB）
- ✅ 超過 5MB 的圖片自動壓縮至 5MB 以下（品質 85-90%）
- ✅ 上傳後立即返回 20 個 Mock 菜項，每項含有完整的 `id`、日文名稱、中文翻譯、規格和價格
- ✅ Mock 數據中每個菜項都包含 `variants` 陣列（至少 1-2 個規格選項）
- ✅ 每個價格都清楚標註「稅込」或「稅拔」
- ✅ UI 正確展示規格選項和對應價格
- ✅ 用戶可勾選菜項（UI 互動正常）
- ✅ 上傳失敗時顯示友善的錯誤提示

---

## Mock 數據範例結構

```json
[
  {
    "id": "item_1",
    "name_jp": "唐揚げ",
    "name_zh": "唐揚雞",
    "variants": [
      { "spec": "單點", "price": 500, "tax_type": "稅込" },
      { "spec": "定食", "price": 800, "tax_type": "稅込" }
    ]
  },
  {
    "id": "item_2",
    "name_jp": "生ビール",
    "name_zh": "生啤酒",
    "variants": [
      { "spec": "大杯", "price": 680, "tax_type": "稅拔" },
      { "spec": "小杯", "price": 480, "tax_type": "稅拔" }
    ]
  }
]
```

---

## 超出範圍 (Out of Scope)

- ❌ Gemini API 真實對接（後續 track）
- ❌ 拍照功能（後續 track）
- ❌ 菜單圖片儲存到 Firebase Storage（後續優化）
- ❌ 圖片裁切、編輯功能
- ❌ 自動計算消費稅（完全依照原圖顯示數字）

---

## 關鍵設計決策

1. **圖片限制與壓縮**：
   - 上傳限制 15MB（支援現代手機照片）
   - 前端自動壓縮超 5MB 的圖片（品質 85-90%）
   - 平衡用戶體驗和後端效率

2. **Mock 數據優先**：
   - 在 Gemini API 對接前，使用結構化的 Mock 數據驗證端到端流程

3. **型別安全**：
   - 使用 TypeScript 確保菜單數據結構的一致性

4. **Clean Architecture**：
   - 業務邏輯（domain）與 UI 層分離，便於後續 API 對接

5. **TDD 開發**：
   - 所有功能透過測試驅動，確保品質 >80% 覆蓋率

---

**狀態**：✅ 已批准
